<!doctype html>
<html lang="lt">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Nustatymai - Auto Laistymas</title>
  <link rel="stylesheet" href="/ui/styles.css">
  <script src="/ui/common.js"></script>
</head>
<body>
  <div class="header">
    <div class="header-content">
      <div class="logo">
        <span>⚙️</span>
        <span>Nustatymai</span>
      </div>
      <div class="nav-links">
        <a href="/" title="Pradžia">🏠</a>
      </div>
      <button id="themeToggle" class="theme-toggle" onclick="toggleTheme()" title="Keisti stilių">
        <span id="themeIcon">🌙</span>
      </button>
    </div>
    <div id="globalMsg" class="global hidden"></div>
  </div>

  <div class="card time-settings-card">
    <h2>🕐 Laistymo laikai (per dieną)</h2>
    <div class="time-list-container">
      <ul id="timesList" class="time-list"></ul>
          </div>
    <div class="time-input-section">
      <div class="time-input-group">
        <label for="newTimeInput">Pridėti laiką (HH:MM)</label>
        <div class="input-with-button">
          <input id="newTimeInput" type="time" step="60" placeholder="06:00" class="time-input">
          <button id="addTimeBtn" type="button" class="add-time-btn">➕ Pridėti</button>
        </div>
        <div class="setting-description">Kada sistema automatiškai pradės laistymą</div>
      </div>
    </div>
    <div class="info-tip">💡 Patarimas: rekomenduojama 1–8 laikai per dieną. Pavyzdys: 06:00 ir 20:00.</div>
  </div>

  <div class="card rtc-settings-card">
    <h2>🕒 Laiko nustatymai (RTC)</h2>
    <div class="rtc-actions">
      <button id="setNowBtn" type="button" class="set-now-btn">🕒 Nustatyti dabartinį naršyklės laiką</button>
    </div>

  </div>

  <div class="card basic-settings-card">
    <h2>⚙️ Baziniai nustatymai</h2>
    <div class="basic-settings-grid">
      <div class="setting-item">
        <label for="wateringDurationMin">Laistymo trukmė (min)</label>
        <input id="wateringDurationMin" type="number" min="1" step="1" placeholder="30" class="setting-input">
                <div class="setting-description">Kiek minučių trunka vienas laistymo ciklas. Per ilgas laistymas gali užlieti augalus, per trumpas - nepatekti vandens. Rekomenduojama: 1-30 minučių, priklausomai nuo augalų poreikių ir dirvožemio tipo.</div>
      </div>
      <div class="setting-item">
        <label for="toleranceWindowMin">Laistymo langas (min)</label>
        <input id="toleranceWindowMin" type="number" min="1" step="1" placeholder="60" class="setting-input">
                <div class="setting-description">Kiek minučių po suplanuoto laiko gali pradėti laistymą. Didesnis langas leidžia sistemai laistyti net jei sąlygos nebuvo tinkamos tiksliai suplanuotu laiku. Rekomenduojama: 15-120 minučių, priklausomai nuo augalų poreikių ir orų sąlygų.</div>
      </div>
      <div class="setting-item">
        <label for="sensorReadIntervalMs">Jutiklių nuskaitymo intervalas (ms)</label>
        <input id="sensorReadIntervalMs" type="number" min="100" step="50" placeholder="1000" class="setting-input">
                <div class="setting-description">Kaip dažnai nuskaitomi BME280 ir vandens lygio jutikliai. Mažesnis intervalas = tiksliau duomenys ir greičiau reaguojama į pokyčius, bet didesnis energijos suvartojimas. Rekomenduojama: 500ms - 5000ms, priklausomai nuo poreikio tikslumui.</div>
      </div>
      <div class="setting-item">
        <label for="pauseResumeCheckIntervalMs">Pauzės tikrinimo intervalas (ms)</label>
        <input id="pauseResumeCheckIntervalMs" type="number" min="100" step="50" placeholder="5000" class="setting-input">
                <div class="setting-description">Kaip dažnai tikrinama, ar galima atnaujinti laistymą po pauzės. Mažesnis intervalas = greičiau atnaujins laistymą, bet daugiau CPU apkrovos. Rekomenduojama: 1000ms - 10000ms, priklausomai nuo poreikio greičiui.</div>
      </div>
    </div>
  </div>

  <div class="card water-level-card">
    <h2>💧 Vandens lygio jutiklis</h2>
    <div class="water-level-grid">
      <div class="setting-item">
        <label for="wlMinState">Minimalus lygio stovis</label>
        <select id="wlMinState" class="setting-select">
          <option value="HIGH">HIGH</option>
          <option value="LOW">LOW</option>
        </select>
                <div class="setting-description">Koks signalas reiškia, kad vandens yra (HIGH arba LOW logika). Dažniausiai HIGH = vandens yra, LOW = vandens nėra, bet priklauso nuo jutiklio tipo ir schemos. Patikrinkite savo jutiklio dokumentaciją arba pabandykite abu variantus.</div>
      </div>
      <div class="setting-item">
        <label for="wlDebounceSamples">Debounce imčių skaičius (1-10)</label>
        <input id="wlDebounceSamples" type="number" min="1" max="10" step="1" placeholder="5" class="setting-input">
                <div class="setting-description">Kiek imčių reikia, kad būtų patvirtintas vandens lygis. Daugiau imčių = stabiliau ir mažiau klaidų, bet lėčiau reaguoja į vandens lygio pokyčius. Rekomenduojama: 3-7 imtys, priklausomai nuo jutiklio stabilumo.</div>
      </div>
      <div class="setting-item">
        <label for="wlDebounceIntervalMs">Debounce intervalas (ms)</label>
        <input id="wlDebounceIntervalMs" type="number" min="1" step="1" placeholder="100" class="setting-input">
                <div class="setting-description">Laikas tarp imčių nuskaitymo. Mažesnis intervalas = greičiau tikrinimas ir reaguojama į pokyčius, bet daugiau energijos suvartojimo. Rekomenduojama: 50ms - 500ms, priklausomai nuo poreikio greičiui ir energijos taupymui.</div>
      </div>
      <div class="setting-item">
        <label for="wlPullMode">Įėjimo režimas</label>
        <select id="wlPullMode" class="setting-select">
          <option value="PULLUP">PULLUP</option>
          <option value="PULLDOWN">PULLDOWN</option>
        </select>
                <div class="setting-description">ESP32 pin'o pull-up arba pull-down rezistorius. PULLUP = 3.3V, PULLDOWN = 0V. Priklauso nuo jutiklio schemos ir ESP32 pin'o. Jei jutiklis neveikia stabiliai, pabandykite pakeisti šį nustatymą.</div>
      </div>
    </div>
  </div>

  <div class="card bme280-card">
    <h2>🌡️ BME280 ribos</h2>
    <div class="bme280-grid">
      <div class="setting-item">
        <label for="bmeTempMin">Temperatūra min (°C)</label>
        <input id="bmeTempMin" type="number" step="0.1" placeholder="10.0" class="setting-input">
                <div class="setting-description">Minimali temperatūra, kurioje leidžiamas laistymas. Per žema temperatūra gali pakenkti augalams ir užšaldyti vandenį. Rekomenduojama: ne žemesnė nei 5°C, priklausomai nuo augalų atsparumo šalčiui.</div>
      </div>
      <div class="setting-item">
        <label for="bmeTempMax">Temperatūra max (°C)</label>
        <input id="bmeTempMax" type="number" step="0.1" placeholder="35.0" class="setting-input">
                <div class="setting-description">Maksimali temperatūra, kurioje leidžiamas laistymas. Per aukšta temperatūra gali išgarinti vandenį ir pakenkti augalams. Rekomenduojama: ne aukštesnė nei 40°C, priklausomai nuo augalų atsparumo karščiui.</div>
      </div>
      <div class="setting-item">
        <label for="bmeHumMin">Drėgmė min (%)</label>
        <input id="bmeHumMin" type="number" step="0.1" placeholder="30.0" class="setting-input">
                <div class="setting-description">Minimali drėgmė, kurioje leidžiamas laistymas. Per žema drėgmė reiškia, kad augalai išdžiūsta ir reikia laistymo. Rekomenduojama: ne žemesnė nei 20%, priklausomai nuo augalų poreikių ir aplinkos sąlygų.</div>
      </div>
      <div class="setting-item">
        <label for="bmeHumMax">Drėgmė max (%)</label>
        <input id="bmeHumMax" type="number" step="0.1" placeholder="80.0" class="setting-input">
                <div class="setting-description">Maksimali drėgmė, kurioje leidžiamas laistymas. Per aukšta drėgmė gali sukelti pelėsį, lėtinti augalų augimą ir sukelti šaknų puvimą. Rekomenduojama: ne aukštesnė nei 90%, priklausomai nuo augalų poreikių ir vėdinimo.</div>
      </div>
      <div class="setting-item">
        <label for="bmePresMin">Slėgis min (hPa)</label>
        <input id="bmePresMin" type="number" step="0.1" placeholder="900.0" class="setting-input">
                <div class="setting-description">Minimalus slėgis, kurioje leidžiamas laistymas. Žemas slėgis gali reikšti audrą, stiprų vėją ar nepalankias orų sąlygas. Rekomenduojama: ne žemesnis nei 850 hPa, priklausomai nuo regiono klimato ir sezoninių pokyčių.</div>
      </div>
      <div class="setting-item">
        <label for="bmePresMax">Slėgis max (hPa)</label>
        <input id="bmePresMax" type="number" step="0.1" placeholder="1100.0" class="setting-input">
                <div class="setting-description">Maksimalus slėgis, kurioje leidžiamas laistymas. Aukštas slėgis gali reikšti saulėtą orą, mažą drėgmę ir didesnį vandens poreikį. Rekomenduojama: ne aukštesnis nei 1200 hPa, priklausomai nuo regiono klimato ir sezoninių pokyčių.</div>
      </div>
    </div>
  </div>

  <div class="card wifi-card">
    <h2>📶 Wi‑Fi (SoftAP)</h2>
    <div class="wifi-grid">
      <div class="setting-item">
        <label for="apSsid">SSID</label>
        <input id="apSsid" type="text" placeholder="AutoLaistymas" class="setting-input">
                <div class="setting-description">WiFi tinklo pavadinimas, kurį sukurs ESP32. Naudokite aiškų ir unikalų pavadinimą, kad lengvai atpažintumėte savo sistemą tinklo sąraše. Pavadinimas gali būti bet koks, bet rekomenduojama naudoti lotyniškas raides ir skaičius.</div>
      </div>
      <div class="setting-item">
        <label for="apPassword">Slaptažodis</label>
        <input id="apPassword" type="text" placeholder="12345678" class="setting-input">
                <div class="setting-description">WiFi tinklo slaptažodis (min 8 simbolių). Naudokite stiprų slaptažodį, kad kiti negalėtų prisijungti prie jūsų sistemos. Rekomenduojama: 8-20 simbolių, įskaitant didžiąsias ir mažąsias raides, skaičius ir specialius simbolius.</div>
      </div>
      <div class="setting-item">
        <label for="apChannel">Kanalas</label>
        <input id="apChannel" type="number" min="1" max="13" step="1" placeholder="1" class="setting-input">
                <div class="setting-description">WiFi kanalas (1-13, rekomenduojama 1, 6 arba 11). Kanalai 1, 6 ir 11 nesikerta tarpusavyje, todėl rekomenduojama pasirinkti mažiausiai užimtą. Jei matote lėtą WiFi greitį ar nutrūkimus, pabandykite pakeisti kanalą.</div>
      </div>
      <div class="setting-item">
        <label for="apHidden">Paslėptas SSID</label>
        <select id="apHidden" class="setting-select">
          <option value="false">Ne</option>
          <option value="true">Taip</option>
        </select>
                <div class="setting-description">Ar WiFi tinklas matomas tinklo sąraše. Paslėptas SSID = saugiau, nes tinklas nematomas kitiems, bet sunkiau prisijungti. Rekomenduojama palikti matomą (Ne) paprastam naudojimui, paslėpti (Taip) - didesniam saugumui.</div>
      </div>
    </div>
    <div class="info-tip">ℹ️ Pastaba: pakeitus SSID, slaptažodį, kanalą ar paslėptą SSID, reikės perkrauti įrenginį.</div>
  </div>

  <div class="card">
    <h2>🔌 Relė</h2>
    <div class="row">
      <div class="col">
        <label for="relayActiveLevel">Aktyvus lygis</label>
        <select id="relayActiveLevel">
          <option value="LOW">LOW (dažniausia)</option>
          <option value="HIGH">HIGH</option>
        </select>
        <div class="setting-description">Koks signalas įjungia relę (LOW = 0V, HIGH = 3.3V). Dauguma relės modulių naudoja LOW = įjungta, HIGH = išjungta. Jei relė neveikia, pabandykite pakeisti šį nustatymą.</div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>🔄 UI atnaujinimas</h2>
    <div class="row">
      <div class="col">
        <label for="uiRefreshMs">Atnaujinimo intervalas (ms)</label>
        <input id="uiRefreshMs" type="number" min="250" step="250" placeholder="1000">
        <div class="setting-description">Kaip dažnai atnaujinama naršyklės sąsaja (ne įrenginio logikai). Mažesnis intervalas = sklandesnė sąsaja ir greičiau matysite pokyčius, bet daugiau tinklo užklausų. Rekomenduojama: 1000ms (1s) - 5000ms (5s).</div>
      </div>
    </div>
  </div>

  <div class="actions">
    <button id="reloadBtn" class="secondary" type="button">🔁 Perkrauti iš /config</button>
  </div>

  <script>
    // Tema valdoma iš common.js

    // pad ir toIsoNoTZ funkcijos iš common.js

    // showMessage funkcija iš common.js

    // Laistymo laikų būsena
    let wateringTimes = [];

    // buildAuthHeaders funkcija iš common.js

    async function loadConfig(){
      showSettingMessage('Konfigūracija', 'Kraunama...', 'info');
      try {
        const res = await fetch('/config');
        if(!res.ok) throw new Error('Atsakymas: '+res.status);
        const cfg = await res.json();
        
        // Baziniai
        document.getElementById('wateringDurationMin').value = cfg.wateringDurationMin ?? '';
        document.getElementById('toleranceWindowMin').value = cfg.toleranceWindowMin ?? '';
        document.getElementById('sensorReadIntervalMs').value = cfg.sensorReadIntervalMs ?? '';
        document.getElementById('pauseResumeCheckIntervalMs').value = cfg.pauseResumeCheckIntervalMs ?? '';
        
        // WL
        document.getElementById('wlMinState').value = cfg.waterLevel?.minState || 'HIGH';
        document.getElementById('wlDebounceSamples').value = cfg.waterLevel?.debounceSamples ?? '';
        document.getElementById('wlDebounceIntervalMs').value = cfg.waterLevel?.debounceIntervalMs ?? '';
        document.getElementById('wlPullMode').value = cfg.waterLevel?.pullMode || 'PULLUP';
        
        // BME
        document.getElementById('bmeTempMin').value = cfg.bme280?.tempMin ?? '';
        document.getElementById('bmeTempMax').value = cfg.bme280?.tempMax ?? '';
        document.getElementById('bmeHumMin').value = cfg.bme280?.humMin ?? '';
        document.getElementById('bmeHumMax').value = cfg.bme280?.humMax ?? '';
        document.getElementById('bmePresMin').value = cfg.bme280?.presMin ?? '';
        document.getElementById('bmePresMax').value = cfg.bme280?.presMax ?? '';
        
        // WiFi
        document.getElementById('apSsid').value = cfg.wifi?.apSsid ?? '';
        document.getElementById('apPassword').value = cfg.wifi?.apPassword ?? '';
        document.getElementById('apChannel').value = cfg.wifi?.apChannel ?? '';
        document.getElementById('apHidden').value = String(cfg.wifi?.apHidden ?? false);
        
        // Relay
        document.getElementById('relayActiveLevel').value = cfg.relay?.activeLevel || 'LOW';
        
        // UI refresh interval from localStorage
        const uiMs = getRefreshMs(); // Naudojame getRefreshMs iš common.js
        document.getElementById('uiRefreshMs').value = uiMs;
        
        // Laistymo laikai
        wateringTimes = Array.isArray(cfg.wateringTimes) ? cfg.wateringTimes.filter(isValidHHMM) : [];
        if(typeof renderTimes === 'function') renderTimes();
        
        showSettingMessage('Konfigūracija', 'Įkelta sėkmingai');
      } catch(e){
        showSettingMessage('Konfigūracija', 'Klaida skaitant: ' + e.message, 'err');
      }
    }

    function collectConfig(){
      const v = id => document.getElementById(id).value;
      const n = id => Number(v(id));
      const cfg = {};

      // Baziniai: tik jei skaičius teisingas
      const addNum = (id, key) => { const num = n(id); if(Number.isFinite(num)) cfg[key] = num; };
      addNum('wateringDurationMin','wateringDurationMin');
      addNum('toleranceWindowMin','toleranceWindowMin');
      addNum('sensorReadIntervalMs','sensorReadIntervalMs');
      addNum('pauseResumeCheckIntervalMs','pauseResumeCheckIntervalMs');

      // WaterLevel
      const wl = {};
      wl.minState = v('wlMinState');
      const wlDebS = n('wlDebounceSamples'); if(Number.isFinite(wlDebS)) wl.debounceSamples = wlDebS;
      const wlDebI = n('wlDebounceIntervalMs'); if(Number.isFinite(wlDebI)) wl.debounceIntervalMs = wlDebI;
      wl.pullMode = v('wlPullMode');
      if(Object.keys(wl).length) cfg.waterLevel = wl;

      // BME
      const bme = {};
      const tmin = n('bmeTempMin'); if(Number.isFinite(tmin)) bme.tempMin = tmin;
      const tmax = n('bmeTempMax'); if(Number.isFinite(tmax)) bme.tempMax = tmax;
      const hmin = n('bmeHumMin'); if(Number.isFinite(hmin)) bme.humMin = hmin;
      const hmax = n('bmeHumMax'); if(Number.isFinite(hmax)) bme.humMax = hmax;
      const pmin = n('bmePresMin'); if(Number.isFinite(pmin)) bme.presMin = pmin;
      const pmax = n('bmePresMax'); if(Number.isFinite(pmax)) bme.presMax = pmax;
      if(Object.keys(bme).length) cfg.bme280 = bme;

      // WiFi
      const wifi = {};
      if(v('apSsid')) wifi.apSsid = v('apSsid');
      if(v('apPassword')) wifi.apPassword = v('apPassword');
      const ch = n('apChannel'); if(Number.isFinite(ch)) wifi.apChannel = ch;
      wifi.apHidden = (v('apHidden') === 'true');
      if(Object.keys(wifi).length) cfg.wifi = wifi;

      // Relay
      cfg.relay = { activeLevel: v('relayActiveLevel') };

      // Watering times (array of HH:MM)
      const items = Array.from(document.querySelectorAll('#timesList li[data-time]')).map(li => li.getAttribute('data-time'));
      cfg.wateringTimes = items;

      return cfg;
    }

    async function saveConfig(){
      try{
        const body = JSON.stringify(collectConfig());
        const headers = Object.assign({ 'Content-Type':'application/json' }, buildAuthHeaders());
        const res = await fetch('/config', { method:'POST', headers, body });
        if(!res.ok) {
        const text = await res.text();
          throw new Error(text||('HTTP '+res.status));
        }
        // Nerodome pranešimo apie išsaugojimą, nes jis jau buvo parodytas validacijoje
      }catch(e){
        showSettingMessage('Konfigūracija', 'Nepavyko išsaugoti: ' + e.message, 'err');
      }
    }

    async function saveTime(){
      const now = new Date();
      const t = toIsoNoTZ(now); // Naudojame toIsoNoTZ iš common.js
      
      showSettingMessage('RTC laikas', 'Siunčiamas...', 'info');
      try{
        const headers = Object.assign({ 'Content-Type':'application/json' }, buildAuthHeaders());
        const res = await fetch('/config/time', { method:'POST', headers, body: JSON.stringify({ time: t }) });
        if(!res.ok) {
        const text = await res.text();
          throw new Error(text||('HTTP '+res.status));
        }
        showSettingMessage('RTC laikas', 'Atnaujintas sėkmingai');
      }catch(e){
        showSettingMessage('RTC laikas', 'Nepavyko atnaujinti: ' + e.message, 'err');
      }
    }

    // Events
    document.getElementById('reloadBtn').addEventListener('click', loadConfig);
    
    document.getElementById('setNowBtn').addEventListener('click', function(){
      saveTime();
    });
    
    // UI refresh interval auto-save on change
    document.getElementById('uiRefreshMs').addEventListener('change', function(){
      const v = document.getElementById('uiRefreshMs').value;
      if(setRefreshMs(v)){ // Naudojame setRefreshMs iš common.js
        // Reikšmė išsaugota sėkmingai
      }
    });

    // Auto-save for all config fields on change/blur (except uiRefreshMs which has own handler)
    function isConfigControl(id){ return !['uiRefreshMs','newTimeInput'].includes(id); }
    function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }
    const debouncedSave = debounce(saveConfig, 500);
    
    // Individualūs pranešimai kiekvienam nustatymui
    function showSettingMessage(settingName, message, type = 'ok') {
      showMessage(`${settingName}: ${message}`, type);
    }
    
    // Ribų tikrinimas ir pranešimai
    function validateAndShowMessage(inputId, value, min, max, settingName, unit = '') {
      const numValue = Number(value);
      if (isNaN(numValue)) {
        showSettingMessage(settingName, 'Neteisinga reikšmė', 'err');
        return false;
      }
      
      if (min !== undefined && numValue < min) {
        showSettingMessage(settingName, `Reikšmė per maža. Minimali: ${min}${unit}`, 'warning');
        return false;
      }
      
      if (max !== undefined && numValue > max) {
        showSettingMessage(settingName, `Reikšmė per didelė. Maksimali: ${max}${unit}`, 'warning');
        return false;
      }
      
      // Nerodome "Išsaugota" pranešimo, nes jis bus rodomas po debouncedSave
      return true;
    }
    
    // Nustatymų validacija su pranešimais
    function validateWateringDuration(value) {
      return validateAndShowMessage('wateringDurationMin', value, 1, 60, 'Laistymo trukmė', ' min');
    }
    
    function validateToleranceWindow(value) {
      return validateAndShowMessage('toleranceWindowMin', value, 5, 180, 'Laistymo langas', ' min');
    }
    
    function validateSensorInterval(value) {
      return validateAndShowMessage('sensorReadIntervalMs', value, 100, 10000, 'Jutiklių intervalas', ' ms');
    }
    
    function validatePauseInterval(value) {
      return validateAndShowMessage('pauseResumeCheckIntervalMs', value, 100, 30000, 'Pauzės intervalas', ' ms');
    }
    
    function validateDebounceSamples(value) {
      return validateAndShowMessage('wlDebounceSamples', value, 1, 10, 'Debounce imtys', '');
    }
    
    function validateDebounceInterval(value) {
      return validateAndShowMessage('wlDebounceIntervalMs', value, 10, 1000, 'Debounce intervalas', ' ms');
    }
    
    function validateTemperature(value, isMin) {
      const min = isMin ? -50 : -50;
      const max = isMin ? 50 : 100;
      const name = isMin ? 'Temperatūra min' : 'Temperatūra max';
      return validateAndShowMessage(isMin ? 'bmeTempMin' : 'bmeTempMax', value, min, max, name, '°C');
    }
    
    function validateHumidity(value, isMin) {
      const min = isMin ? 0 : 0;
      const max = isMin ? 100 : 100;
      const name = isMin ? 'Drėgmė min' : 'Drėgmė max';
      return validateAndShowMessage(isMin ? 'bmeHumMin' : 'bmeHumMax', value, min, max, name, '%');
    }
    
    function validatePressure(value, isMin) {
      const min = isMin ? 500 : 500;
      const max = isMin ? 1500 : 1500;
      const name = isMin ? 'Slėgis min' : 'Slėgis max';
      return validateAndShowMessage(isMin ? 'bmePresMin' : 'bmePresMax', value, min, max, name, ' hPa');
    }
    
    // Event listeners su individualiais pranešimais
    document.addEventListener('change', function(e){ 
      if(e.target && (e.target.tagName==='INPUT'||e.target.tagName==='SELECT')){ 
        if(isConfigControl(e.target.id)) {
          // Tik validuojame, nerodome "Išsaugota" pranešimo
          let isValid = true;
          switch(e.target.id) {
            case 'wateringDurationMin':
              isValid = validateWateringDuration(e.target.value);
              break;
            case 'toleranceWindowMin':
              isValid = validateToleranceWindow(e.target.value);
              break;
            case 'sensorReadIntervalMs':
              isValid = validateSensorInterval(e.target.value);
              break;
            case 'pauseResumeCheckIntervalMs':
              isValid = validatePauseInterval(e.target.value);
              break;
            case 'wlDebounceSamples':
              isValid = validateDebounceSamples(e.target.value);
              break;
            case 'wlDebounceIntervalMs':
              isValid = validateDebounceInterval(e.target.value);
              break;
            case 'bmeTempMin':
              isValid = validateTemperature(e.target.value, true);
              break;
            case 'bmeTempMax':
              isValid = validateTemperature(e.target.value, false);
              break;
            case 'bmeHumMin':
              isValid = validateHumidity(e.target.value, true);
              break;
            case 'bmeHumMax':
              isValid = validateHumidity(e.target.value, false);
              break;
            case 'bmePresMin':
              isValid = validatePressure(e.target.value, true);
              break;
            case 'bmePresMax':
              isValid = validatePressure(e.target.value, false);
              break;
            case 'wlMinState':
            case 'wlPullMode':
            case 'relayActiveLevel':
            case 'apSsid':
            case 'apPassword':
            case 'apChannel':
            case 'apHidden':
              // Select ir text input'ai neturi validacijos, tik išsaugojimas
              break;
            default:
              // Nerodome nieko
          }
          
          // Išsaugojame tik jei validacija sėkminga
          if (isValid) {
            debouncedSave();
          }
        }
      }
    });
    
    document.addEventListener('blur', function(e){ 
      if(e.target && (e.target.tagName==='INPUT')){ 
        if(isConfigControl(e.target.id)) {
          // Blur event'e tik išsaugojame, nerodome pranešimų
          debouncedSave(); 
        }
      } 
    }, true);

    // Init
    loadConfig();

    // --- Laistymo laikų UI ---
    // isValidHHMM funkcija iš common.js
    
    function renderTimes(){
      const ul = document.getElementById('timesList');
      ul.innerHTML = '';
      wateringTimes.forEach((t, idx) => {
        const li = document.createElement('li');
        li.setAttribute('data-time', t);
        const span = document.createElement('span'); 
        span.textContent = t;
        const btn = document.createElement('button'); 
        btn.type='button'; 
        btn.textContent='✖'; 
        btn.className='secondary';
        btn.addEventListener('click', ()=>{ 
          removeWateringTime(idx);
        });
        li.appendChild(span); 
        li.appendChild(btn); 
        ul.appendChild(li);
      });
    }

    document.getElementById('addTimeBtn').addEventListener('click', ()=>{
      const t = (document.getElementById('newTimeInput').value||'').trim();
      if(!isValidHHMM(t)){ 
        showSettingMessage('Laistymo laikas', 'Blogas formatas. Naudokite HH:MM', 'err'); 
        return; 
      }
      if(wateringTimes.includes(t)){ 
        showSettingMessage('Laistymo laikas', 'Toks laikas jau yra', 'warning'); 
        return; 
      }
      if(wateringTimes.length>=8){ 
        showSettingMessage('Laistymo laikas', 'Pasiektas maksimalus laikų skaičius (8)', 'warning'); 
        return; 
      }
      wateringTimes.push(t);
      wateringTimes.sort();
      renderTimes();
      debouncedSave();
      document.getElementById('newTimeInput').value = '';
      showSettingMessage('Laistymo laikas', 'Pridėta: ' + t);
    });
    
    // Individualūs pranešimai laistymo laikų trinimui
    function removeWateringTime(index) {
      const removedTime = wateringTimes[index];
      wateringTimes.splice(index, 1);
      renderTimes();
      debouncedSave();
      showSettingMessage('Laistymo laikas', 'Pašalinta: ' + removedTime);
    }


  </script>
</body>
</html>
